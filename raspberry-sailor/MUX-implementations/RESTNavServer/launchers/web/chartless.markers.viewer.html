<!DOCTYPE html>
<!--
 | Chartless Map markers viewer, for validation.
 | Display JSON data generated by util.MarkersToJSON (markers.to.json.sh)
 +-->
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Chartless Map</title>
    <link rel="icon" type="image/ico" href="./icons/hammerhead.02.ico">
	<style type="text/css">
html {
	font-family: "Courier New"
}

.html-01 {
	background-color: white;
	color: black;
}
.html-02 {
	background-color: gray;
	color: cyan;
}
.html-03 {
	background-color: black;
	color: silver;
}

.chartless-map-01 {
	--bg-color: rgba(224, 215, 215, 0.5);
	--grid-color: rgba(0, 0, 0, 0.7);
	--fg-color: gray;
	--marker-and-track-color: navy;
	--target-color: green;
	--border-color: blue;
	--value-font: 'Courier New';
}
.chartless-map-02 {
	--bg-color: rgba(0, 0, 0, 0.5);
	--grid-color: lime;
	--fg-color: lime;
	--marker-and-track-color: cyan;
	--target-color: lime;
	--border-color: cyan;
	--value-font: 'Courier New';
}
.chartless-map-03 {
	--bg-color: rgb(62, 58, 58);
	--grid-color: cyan;
	--fg-color: cyan;
	--marker-and-track-color: cyan;
	--target-color: lime;
	--border-color: cyan;
	--value-font: 'Courier New';
}
	</style>

	<script type="text/javascript">
let originalFetch = fetch;		// TODO Fix that !! This is ugly !
	</script>

	<!--script type="text/javascript" src="js/date.proto.js"></script>
	<script type="text/javascript" src="js/pub.sub.js"></script>
	<script type="text/javascript" src="js/ajax.manager.js"></script-->
	<script type="text/javascript" src="./webcomponents/utilities/NavigationHelper.js"></script>

	<script type="module" src="./webcomponents/ChartlessMap.js"></script>

	<script type="text/javascript">

const VERBOSE = true;		

let map; 
let markers = [];
let borders = [];

// const MARKERS_DATA = "./json/markers.yaml.json";
const MARKERS_DATA = "./json/markers.north.ria.yaml.json";
let pos = { lat: 47.7 / -3.13 }; // Hard coded

// const MARKERS_DATA = "./json/markers.houat.hoedic.belle-ile.yaml.json";
// let pos = { lat: 47.5, lng: -3 }; // Hard-coded

let loadData = (fn) => {
	originalFetch(MARKERS_DATA)
		.then(response => {
			console.log(`Data Response: ${response.status} - ${response.statusText}`);
			document.getElementById('filename').innerHTML = `Rendering ${MARKERS_DATA}`;
			response.json().then(doc => {
				markers = doc["markers-data"];
				borders = doc["borders-data"];
				console.log(`Data loaded`);
				// Center in the middle, find it.
				let minLat = 90, maxLat = -90;
				let minLng = 180, maxLng = -180;
				markers.forEach(mark => {
					minLat = Math.min(minLat, mark.latitude);
					maxLat = Math.max(maxLat, mark.latitude);
					
					minLng = Math.min(minLng, mark.longitude);
					maxLng = Math.max(maxLng, mark.longitude);
				});
				borders.forEach(border => {
					border.markerList.forEach(mark => {
						minLat = Math.min(minLat, mark.latitude);
						maxLat = Math.max(maxLat, mark.latitude);
						
						minLng = Math.min(minLng, mark.longitude);
						maxLng = Math.max(maxLng, mark.longitude);
					});
				});
				pos.lat = (maxLat + minLat) / 2;
				pos.lng = (maxLng + minLng) / 2;
				if (centerOnBoat) {
					map.centerLat = pos.lat; // This does the repaint...
					map.centerLng = pos.lng;
				}
				// Map width ?
				// let chartWidth = (Math.abs(maxLng - minLng) / 50).toFixed(2) * 50;
				let chartWidth = Math.abs(maxLng - minLng);
				document.getElementById('ChartWidth').innerText = chartWidth;
				map.chartWidth = chartWidth;

				console.log(`Centered on ${ JSON.stringify(pos) }`);

				if (map !== undefined) {
					map.repaint();
				} else {
					console.log("Map not loaded yet...");
				}

				if (fn) {
					console.log("Executing next func.");
					fn();
				}
			});
		}, (error, errmess) => {
			console.log("Ooch");
			let message;
			if (errmess) {
				let mess = JSON.parse(errmess);
				if (mess.message) {
					message = mess.message;
				}
			}
			console.debug("Failed to get Path data..." + (error ? JSON.stringify(error, null, 2) : ' - ') + ', ' + (message ? message : ' - '));
		});
};

function displayErr(err) {
	if (err) {
		// document.getElementById("err-mess").innerHTML = ("<small>" + err + "</small>");
		console.log(err);
	}
}

function onSlider(event) {
	if (VERBOSE) {
		console.log(`Setting chart width to ${this.value}.`);
	}
	if (this.value > 0) {
    	map.chartWidth = this.value;
	} else {
		console.log(`Chart width ${this.value} !!`);
	}
}

function zoomIn() {
	let currentWidth = map.chartWidth;
	let newWidth = (currentWidth * 0.89); // .toFixed(1);
	map.chartWidth = newWidth;
	map.repaint();
	document.getElementById('ChartWidth').innerText = newWidth;
}
function zoomOut() {
	let currentWidth = map.chartWidth;
	let newWidth = (currentWidth * 1.11); // .toFixed(1);
	map.chartWidth = newWidth;
	map.repaint();
	document.getElementById('ChartWidth').innerText = newWidth;
}

let centerOnBoat = true;
let displayMarkers = true;
let displayBorders = true;
let displayBorderMarkers = false;
let withDistBearing = false;

let boatRadius = 10;

let markerAndTrackColor = 'navy';

/*
 * Used as the doAfter callback on the ChartlessMap.
 */
let updateMap = (elmt, context) => {
	
	if (false) { // Plot Chart Center 
		let center = elmt.posToCanvas(elmt._centerLat, elmt._centerLng);

		context.save();

		context.beginPath();
		context.strokeStyle = 'red';
		context.lineWidth = 1;
		// console.log(`Plotting chart center on ${center.x} x ${center.y}`);
		context.moveTo(center.x, center.y - 20);
		context.lineTo(center.x, center.y + 20);
	
		context.moveTo(center.x - 20, center.y);
		context.lineTo(center.x + 20, center.y);
		context.stroke();
		context.closePath();
	
		context.beginPath();
		context.lineWidth = 4;
		context.arc(center.x, center.y, 10, 0, 2 * Math.PI, false);

		context.stroke();
		context.closePath();
	
		context.restore();
	}

	// Markers.
	if (VERBOSE) {
		console.log(`${markers.length} markers`);
	}
	if (displayMarkers) {
		context.save();
		let markerRadius = 10;
		let beaconHeight = 2 * markerRadius;
		markers.forEach(marker => {
			let extraMess = [];
			if (pos && withDistBearing) {
				// Calculate distance and bearing to mark
				// 1 - Distance
				let dist = NavigationHelper.getGCDistanceInNM({ lat: Math.toRadians(pos.lat), lng: Math.toRadians(pos.lng) }, 
							                                  { lat: Math.toRadians(marker.latitude), lng: Math.toRadians(marker.longitude) });
				let distMess = `Distance: ${dist.toFixed(2)} nm`;
				extraMess.push(distMess);
				// 2 - Bearing
				let from = { lat: Math.toRadians(pos.lat), lng: Math.toRadians(pos.lng) };
				let to = { lat: Math.toRadians(marker.latitude), lng: Math.toRadians(marker.longitude) };
				let bearing = NavigationHelper.getBearingInDegrees(from, to);
				let bearingMess = `Bearing: ${bearing.toFixed(0)}\u00b0`;
				extraMess.push(bearingMess);
			}
			elmt.plotMark(context, marker, markerRadius, beaconHeight, elmt.colorConfig.markerAndTrackColor, extraMess); // method defined in the ChartlessMap
		});
		context.restore();
	}

	// Borders.
	if (VERBOSE) {
		console.log(`${borders.length} borders`);
	}
	if (displayBorders) {
		context.save();
		let markerRadius = 10;
		let beaconHeight = 2 * markerRadius;
		borders.forEach(border => {
			let extraMess = [];
			let borderName = border.borderName;
			let markerList = border.markerList;
			// console.log(`Border [${borderName}]`);

			let plotBorder = [];
			// Plot markers
			markerList.forEach((marker, idx) => {
				let plotIt = true;
				// Manage closed borders, don't plot the last point...
				if (idx > 0 && marker.latitude === markerList[0].latitude && marker.longitude === markerList[0].longitude) {  // Last point of a closed border
					plotIt = false;
				}
				if (plotIt && displayBorderMarkers) { // false || idx < (markerList.length - 1)) { 
					elmt.plotMark(context, marker, markerRadius, beaconHeight, elmt.colorConfig.borderColor, extraMess);
				}
				let plot = elmt.posToCanvas(marker.latitude, marker.longitude);
				plotBorder.push(plot);
			});

			// Draw border
			context.save();
			context.beginPath();
			context.strokeStyle = elmt.colorConfig.borderColor; // 'blue';
			context.lineWidth = 2;

			if (plotBorder.length > 0) {
				// console.log(`Border: plotting ${plotBorder.length} segments.`);
				context.moveTo(plotBorder[0].x, plotBorder[0].y); // idx 0
				for (let i=1; i<plotBorder.length; i++) {         // the rest, starts at 1
					context.lineTo(plotBorder[i].x, plotBorder[i].y);
				}
			}
			context.stroke();
			context.closePath();
			context.restore();
		});
		context.restore();
	}

	// context.stroke();
	// context.closePath();
};

let lpad = (str, len, pad) => {
	let s = str;
	while (s.length < len) {
		s = (pad === undefined ? ' ' : pad) + s;
	}
	return s;
};

let decToSex = (val, ns_ew) => {
	let absVal = Math.abs(val);
	let intValue = Math.floor(absVal);
	let dec = absVal - intValue;
	let i = intValue;
	dec *= 60;
//    var s = i + "Â°" + dec.toFixed(2) + "'";
//    var s = i + String.fromCharCode(176) + dec.toFixed(2) + "'";
	let s = "";
	if (ns_ew !== undefined) {
		if (val < 0) {
			s += (ns_ew === 'NS' ? 'S' : 'W');
		} else {
			s += (ns_ew === 'NS' ? 'N' : 'E');
		}
		s += " ";
	} else {
		if (val < 0) {
			s += '-'
		}
	}
	s += i + "\xba" + lpad(dec.toFixed(2), 5, '0') + "'";

	return s;
};

let centerChart = (cb) => {
	centerOnBoat = cb.checked;
	if (centerOnBoat) {
		map.centerLat = pos.lat; // This does the repaint...
		map.centerLng = pos.lng;
	} else {
		map.repaint();
	}
};
let plotMarkers = (cb) => {
	displayMarkers = cb.checked;
	map.repaint();
};
let plotBorders = (cb) => {
	displayBorders = cb.checked;
	map.repaint();
};
let plotBorderMarkers = (cb) => { 
	displayBorderMarkers = cb.checked;
	map.repaint();
}
let distBearing = (cb) => {
	withDistBearing = cb.checked;
	map.repaint();
};

let setStyle = (opt) => {
	let map = document.getElementById('chartless-map-01');
	document.getElementById('chartless-map-01').className = opt.value;

	switch (opt.value) {
		case 'chartless-map-03':
			// markerAndTrackColor = 'cyan';
			map.colorConfig.markerAndTrackColor = 'cyan';
			map.colorConfig.targetColor = 'lime';
			map.colorConfig.borderColor = 'cyan';
			document.body.className = 'html-03';
			break;
		case 'chartless-map-02':
			// markerAndTrackColor = 'cyan';
			map.colorConfig.markerAndTrackColor = 'lightcyan';
			map.colorConfig.targetColor = 'lime';
			map.colorConfig.borderColor = 'cyan';
			document.body.className = 'html-02';
			break;
		case 'chartless-map-01':
		default:
			// markerAndTrackColor = 'navy';
			map.colorConfig.markerAndTrackColor = 'navy';
			map.colorConfig.targetColor = 'green';
			map.colorConfig.borderColor = 'blue';
			document.body.className = 'html-01';
			break;
	}
};

window.onload = () => {
	loadData();
	// initAjax(false, ping=250); // ping ununsed
	// console.log("Commented initAjax!");

	map = document.getElementById('chartless-map-01');
	map.setDoAfter(updateMap);        	
	if (centerOnBoat) {
		map.centerLat = pos.lat; // This does the repaint...
		map.centerLng = pos.lng;
	}
	// map.repaint();
}
	</script>
</head>
<body>
	<h1>Viewer for Markers and Borders</h1>
	<div id="filename"></div>
    <table>
        <tr>
            <td valign="top" style="height: 600px;">
                <div style="border: 1px solid silver; border-radius: 5px; padding: 10px;">
                    <chartless-map id="chartless-map-01"
                                   class="chartless-map-01"
                                   center-lat="47.0"
                                   center-lng="-3.0"
                                   chart-width="5.0"
                                   width="1000"
                                   height="600"></chartless-map>
                </div>
            </td>
			<td valign="top" rowspan="3">
				<table>
					<tr>
						<td>Style:</td>
						<td>
							<select id="chart-style" onchange="setStyle(this);" style="width: 90%; font-family: 'Courier New';">
								<option value="chartless-map-01" selected>Light</option>
								<option value="chartless-map-02">Dark</option>
								<option value="chartless-map-03">Darker</option>
							</select>
						</td>
					</tr>
				</table>
			</td>
        </tr>
        <tr>
            <td valign="top" height="50">
                <!-- A slider for the chart scale -->
                <!--div id="div-slider" style="text-shadow: 2px 2px 4px gray, 0 0 25px white, 0 0 10px orange;">
					Chart Width:
                    <input type="range" id="scale-slider" value="5.0" min="0.01" max="100.0" step="0.01" style="width: 600px;" title="Chart's width in degrees"
                           oninput="onSlider.call(this, event); sliderValue01.value = `${decToSex(parseFloat(this.value).toFixed(2))}`;"/>
                    <output name="padding" id="sliderValue01" style="text-shadow: 2px 2px 4px gray, 0 0 25px white, 0 0 10px orange;">5&deg;00.00'</output>
                </div-->
				<!-- Zoom in / out -->
				<button onclick="zoomIn();">Zoom in</button> <button onclick="zoomOut();">Zoom out</button> Chart Width: <span id="ChartWidth">5</span>&deg;
            </td>
        </tr>
		<tr>
			<td valign="top">
				<div style="display: grid; grid-template-columns: auto auto auto auto auto auto;">
					<input type="checkbox" onchange="centerChart(this);" checked>Center Chart on the boat
					<input type="checkbox" onchange="plotBorders(this);" checked>Plot Borders
					<input type="checkbox" onchange="plotBorderMarkers(this);">Plot Borders' Markers
					<!--br/-->
					<input type="checkbox" onchange="plotMarkers(this);" checked>Plot Markers
					<input type="checkbox" onchange="distBearing(this);">Dist &amp; Bearings
				</div>
			</td>
		</tr>
    </table>
</body>
</html>
